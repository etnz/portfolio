package portfolio

import (
	"fmt"
	"iter"
	"maps"
	"slices"
)

// Balance represents the calculated state of the portfolio at a specific point in time.
// It is generated by processing events from a Journal.
type Balance struct {
	cur string // reporting currency
	on  Date
	// cashAccounts holds the balance for each currency.
	cashAccounts map[string]Money
	// cashFlows holds the money that goes in or out the portfolio.
	cashFlows map[string]Money
	// counterpartyAccounts holds the balance for each external account.
	counterpartyAccounts map[string]Money
	// counterpartyCur record counterparty currency
	counterpartyCur map[string]string
	// securities holds the definitions for declared tickers.
	securities map[string]Security
	// lots holds the open lots for each security ticker, crucial for cost basis calculation.
	lots map[string]lots
	// realizedGains holds the cumulative realized gains for each security ticker.
	realizedGains map[string]Money
	// buys holds the total amount spent on buying a security.
	buys map[string]Money
	// sells holds the total amount received from selling a security.
	sells map[string]Money
	// prices holds the price of each security.
	prices map[string]Money
	// forex rate to convert to the reporting currency.
	forex map[string]Money

	// linkedTWR are percentages, not currency or quantities, and therefore are better represented as float64
	linkedTWR     float64
	lastValuation float64 // The total portfolio value at the last cash flow event.
}

func (b *Balance) Security(security string) Security {
	return b.securities[security]
}

// Price returns the current price for a given ticker.
func (b *Balance) Price(ticker string) Money {
	return b.prices[ticker]
}

// newBalance creates an initialized, empty Balance object.
func newBalance(on Date) *Balance {
	return &Balance{
		on:                   on,
		cashAccounts:         make(map[string]Money),
		cashFlows:            make(map[string]Money),
		counterpartyAccounts: make(map[string]Money),
		counterpartyCur:      make(map[string]string),
		securities:           make(map[string]Security),
		lots:                 make(map[string]lots),
		realizedGains:        make(map[string]Money),
		buys:                 make(map[string]Money),
		sells:                make(map[string]Money),
		prices:               make(map[string]Money),
		forex:                make(map[string]Money),
		linkedTWR:            1.0,
		lastValuation:        0,
	}
}

// NewBalance calculates the portfolio's state by processing all journal events
// up to and including the specified date 'on'.
func NewBalance(j *Journal, on Date, method CostBasisMethod) (*Balance, error) {
	balance := newBalance(on)
	balance.cur = j.cur
	for _, e := range j.events {
		if e.date().After(on) {
			break // Events are sorted, so we can stop.
		}

		if err := balance.apply(e, method); err != nil {
			return nil, fmt.Errorf("failed to apply event on %s: %w", e.date(), err)
		}
	}
	// call computeTWR to account for the interval between the last cash flow and the report date
	balance.computeTWR(M(0, balance.cur))
	return balance, nil
}

func (b *Balance) computeTWR(cashFlowAmount Money) {
	// Compute is done in float, because we keep ratio between
	// Calculate the portfolio value *before* this cash flow.
	// computeTWR is called before applying a cashfloat even, therefore the TotalPortfolioValue is
	// the value before the relative cashflow amount.
	valueBeforeCF := b.TotalPortfolioValue().AsFloat() // You'll need to create this helper method.

	// If this isn't the very first cash flow, calculate the sub-period return.
	if b.lastValuation != 0 {
		// Geometrically link this return to the running total.
		b.linkedTWR *= valueBeforeCF / b.lastValuation
	}
	// Update the lastValuation to the value *after* the cash flow.
	b.lastValuation = valueBeforeCF + cashFlowAmount.AsFloat()

}

// apply processes a single event and updates the Balance state accordingly.
func (b *Balance) apply(e event, method CostBasisMethod) error {
	switch v := e.(type) {
	case creditCash:
		b.computeTWR(v.amount)
		b.cashAccounts[v.currency()] = b.cashAccounts[v.currency()].Add(v.amount)
		if v.external {
			b.cashFlows[v.currency()] = b.cashFlows[v.currency()].Add(v.amount)
		}
	case debitCash:
		b.computeTWR(v.amount.Neg())
		b.cashAccounts[v.currency()] = b.cashAccounts[v.currency()].Sub(v.amount)
		if v.external {
			b.cashFlows[v.currency()] = b.cashFlows[v.currency()].Sub(v.amount)
		}
	case acquireLot:
		newLot := lot{
			Date:     v.on,
			Quantity: v.quantity,
			Cost:     v.cost,
		}
		b.lots[v.security] = append(b.lots[v.security], newLot)
		b.buys[v.security] = b.buys[v.security].Add(v.cost)
	case disposeLot:
		currentLots := b.lots[v.security]
		var costOfSale Money

		switch method {
		case FIFO:
			costOfSale = currentLots.fifoCostOfSelling(v.quantity)
		case AverageCost:
			costOfSale = currentLots.averageCostOfSelling(v.quantity)
		default:
			return fmt.Errorf("unsupported cost basis method: %v", method)
		}

		b.lots[v.security] = currentLots.sell(v.quantity)
		gain := v.proceeds.Sub(costOfSale)
		b.realizedGains[v.security] = b.realizedGains[v.security].Add(gain)
		b.sells[v.security] = b.sells[v.security].Add(v.proceeds)

	case creditCounterparty:
		b.counterpartyAccounts[v.account] = b.counterpartyAccounts[v.account].Add(v.amount)
		if v.external {
			b.cashFlows[v.currency()] = b.cashFlows[v.currency()].Add(v.amount)
		}
	case debitCounterparty:
		b.counterpartyAccounts[v.account] = b.counterpartyAccounts[v.account].Sub(v.amount)
		if v.external {
			b.cashFlows[v.currency()] = b.cashFlows[v.currency()].Sub(v.amount)
		}
	case splitShare:
		num := Q(v.numerator)
		den := Q(v.denominator)
		for i, l := range b.lots[v.security] {
			b.lots[v.security][i].Quantity = l.Quantity.Mul(num).Div(den)
		}
	case declareSecurity:
		b.securities[v.ticker] = NewSecurity(v.id, v.ticker, v.currency)
	case declareCounterparty:
		b.counterpartyCur[v.account] = v.currency
	case updatePrice:
		b.prices[v.security] = v.price
	case updateForex:
		b.forex[v.currency] = v.rate
	default:
		return fmt.Errorf("unknown event type: %T", v)
	}
	return nil
}

// Currency returns the reporting currency for aggregated metrics.
func (b *Balance) Currency() string { return b.cur }

// Currencies returns a iteration over all existing currency in the balance.
func (b *Balance) Currencies() iter.Seq[string] {
	currencies := make(map[string]struct{})
	for cur := range b.cashAccounts {
		currencies[cur] = struct{}{}
	}
	for _, sec := range b.securities {
		currencies[sec.Currency()] = struct{}{}
	}
	for _, cur := range b.counterpartyCur {
		currencies[cur] = struct{}{}
	}
	currencies[b.cur] = struct{}{} // Add reporting currency
	keys := slices.Collect(maps.Keys(currencies))
	slices.Sort(keys)
	return slices.Values(keys)
}

// Securities returns an interator over all securities in the balance.
func (b *Balance) Securities() iter.Seq[Security] {
	keys := slices.Collect(maps.Keys(b.securities))
	slices.Sort(keys)
	return func(yield func(Security) bool) {
		for _, ticker := range keys {
			if !yield(b.securities[ticker]) {
				return
			}
		}
	}
}

func (b *Balance) Counterparties() iter.Seq[string] {
	keys := slices.Collect(maps.Keys(b.counterpartyAccounts))
	slices.Sort(keys)
	return slices.Values(keys)
}

// Position returns the quantity of a security held.
func (b *Balance) Position(ticker string) Quantity {
	var totalQuantity Quantity
	for _, l := range b.lots[ticker] {
		totalQuantity = totalQuantity.Add(l.Quantity)
	}
	return totalQuantity
}

// CostBasis returns the total cost basis of a security.
func (b *Balance) CostBasis(ticker string) Money {
	var totalCost Money
	for _, l := range b.lots[ticker] {
		totalCost = totalCost.Add(l.Cost)
	}
	return totalCost
}

// RealizedGain returns the realized gain of a security.
func (b *Balance) RealizedGain(ticker string) Money {
	g := b.realizedGains[ticker]
	// if there was no transactions, the Money is the zero value without currency. Add it.
	if g.cur == "" {
		g.cur = b.securities[ticker].currency
	}
	return g
}

// MarketValue returns the total market value of a security.
func (b *Balance) MarketValue(ticker string) Money {
	price, ok := b.prices[ticker]
	if !ok {
		return M(0, b.securities[ticker].currency)
	}
	return price.Mul(b.Position(ticker))
}

// Return returns the TWR return since inception
func (b *Balance) Return() float64 {
	return b.linkedTWR - 1.0
}

// Convert amount in 'currency' to the reporting currency.
func (b *Balance) Convert(amount Money) Money {
	if amount.Currency() == b.cur {
		return amount
	} else {
		rate := b.forex[amount.Currency()]
		return rate.Mul(Q(amount.value))
	}
}

// Cash returns the balance of a specific currency.
func (b *Balance) Cash(currency string) Money {
	c, ok := b.cashAccounts[currency]
	if !ok {
		return M(0, currency)
	}
	return c
}

// CashFlow returns the total cash flow for a specific currency.
func (b *Balance) CashFlow(currency string) Money {
	f, ok := b.cashFlows[currency]
	if !ok {
		return M(0, currency)
	}
	return f
}

// Counterparty returns the balance of a specific counterparty account.
func (b *Balance) Counterparty(account string) Money {
	c, ok := b.counterpartyAccounts[account]
	if !ok {
		cur := b.counterpartyCur[account]
		return M(0, cur)
	}
	return c
}

// CounterpartyCurrency	returns the currency of a specific counterparty account.
func (b *Balance) CounterpartyCurrency(account string) string {
	return b.counterpartyCur[account]
}

// TotalRealizedGain returns the total realized gains accross all holdings.
func (b *Balance) TotalRealizedGain() Money {
	var total Money = M(0, b.cur)
	for _, gain := range b.realizedGains {
		gain = b.Convert(gain)
		total = total.Add(gain)
	}
	return total
}

// TotalUnealizedGain returns the total realized gains accross all holdings.
func (b *Balance) TotalUnrealizedGain() Money {
	return b.TotalMarketValue().Sub(b.TotalCostBasis())
}

// TotalMarketValue returns the total market value of all securities in the portfolio.
func (b *Balance) TotalMarketValue() Money {
	var total Money = M(0, b.cur)
	for ticker := range b.securities {
		mv := b.MarketValue(ticker)
		mv = b.Convert(mv)
		total = total.Add(mv)
	}
	return total
}

func (b *Balance) TotalCostBasis() Money {
	var total Money = M(0, b.cur)
	for ticker := range b.securities {
		mv := b.CostBasis(ticker)
		mv = b.Convert(mv)
		total = total.Add(mv)
	}
	return total
}

// TotalCash returns the total cash balance across all currencies, converted to the reporting currency.
func (b *Balance) TotalCash() Money {
	var total Money = M(0, b.cur)
	for _, amount := range b.cashAccounts {
		total = total.Add(b.Convert(amount))
	}
	return total
}

// TotalCashFlow returns the total cash flow across all currencies, converted to the reporting currency.
func (b *Balance) TotalCashFlow() Money {
	var total Money = M(0, b.cur)
	for _, amount := range b.cashFlows {
		total = total.Add(b.Convert(amount))
	}
	return total
}

// TotalCounterparty returns the total balance across all counterparty accounts, converted to the reporting currency.
func (b *Balance) TotalCounterparty() Money {
	var total Money = M(0, b.cur)
	for _, amount := range b.counterpartyAccounts {
		total = total.Add(b.Convert(amount))
	}
	return total
}

// TotalPortfolioValue returns the total value of the portfolio, including securities, cash, and counterparty accounts.
func (b *Balance) TotalPortfolioValue() Money {
	return b.TotalMarketValue().
		Add(b.TotalCash()).
		Add(b.TotalCounterparty())
}

// Buys returns the total amount spent on buying a given security up to the balance's `on` date.
func (b *Balance) Buys(ticker string) Money {
	buy, ok := b.buys[ticker]
	if !ok {
		// Ensure a zero-value Money with the correct currency is returned if no buys exist.
		if sec, ok := b.securities[ticker]; ok {
			return M(0, sec.Currency())
		}
	}
	return buy
}

// Sells returns the total amount received from selling a given security up to the balance's `on` date.
func (b *Balance) Sells(ticker string) Money {
	sell, ok := b.sells[ticker]
	if !ok {
		if sec, ok := b.securities[ticker]; ok {
			return M(0, sec.Currency())
		}
	}
	return sell
}

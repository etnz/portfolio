package portfolio

import (
	"fmt"
	"iter"
	"maps"
	"slices"

	"github.com/etnz/portfolio/date"
	"github.com/shopspring/decimal"
)

// Balance represents the calculated state of the portfolio at a specific point in time.
// It is generated by processing events from a Journal.
type Balance struct {
	cur string // reporting currency
	// cashAccounts holds the balance for each currency.
	cashAccounts map[string]decimal.Decimal
	// counterpartyAccounts holds the balance for each external account.
	counterpartyAccounts map[string]decimal.Decimal
	// counterpartyCur record counterparty currency
	counterpartyCur map[string]string
	// securities holds the definitions for declared tickers.
	securities map[string]Security
	// lots holds the open lots for each security ticker, crucial for cost basis calculation.
	lots map[string]lots
	// realizedGains holds the cumulative realized gains for each security ticker.
	realizedGains map[string]decimal.Decimal
	// prices holds the price of each security.
	prices map[string]decimal.Decimal
	// forex rate to convert to the reporting currency.
	forex map[string]decimal.Decimal

	// linkedTWR are percentages, not currency or quantities, and therefore are better represented as float64
	linkedTWR     float64
	lastValuation float64         // The total portfolio value at the last cash flow event.
	initialValue  decimal.Decimal // First cash deposit, or accrued value
}

// Price returns the current price for a given ticker.
func (b *Balance) Price(ticker string) decimal.Decimal {
	return b.prices[ticker]
}

// NewBalance creates an initialized, empty Balance object.
func NewBalance() *Balance {
	return &Balance{
		cashAccounts:         make(map[string]decimal.Decimal),
		counterpartyAccounts: make(map[string]decimal.Decimal),
		counterpartyCur:      make(map[string]string),
		securities:           make(map[string]Security),
		lots:                 make(map[string]lots),
		realizedGains:        make(map[string]decimal.Decimal),
		prices:               make(map[string]decimal.Decimal),
		forex:                make(map[string]decimal.Decimal),
		linkedTWR:            1.0,
		lastValuation:        0,
	}
}

// NewBalanceFromJournal calculates the portfolio's state by processing all journal events
// up to and including the specified date 'on'.
func NewBalanceFromJournal(j *Journal, on date.Date, method CostBasisMethod) (*Balance, error) {
	balance := NewBalance()
	balance.cur = j.cur
	for _, e := range j.events {
		if e.date().After(on) {
			break // Events are sorted, so we can stop.
		}

		if err := balance.apply(e, method); err != nil {
			return nil, fmt.Errorf("failed to apply event on %s: %w", e.date(), err)
		}
	}
	// call computeTWR to account for the interval between the last cash flow and the report date
	balance.computeTWR(decimal.Zero)
	return balance, nil
}

func (b *Balance) computeTWR(cashFlowAmount decimal.Decimal) {
	{
		// 1. Calculate the portfolio value *before* this cash flow.
		valueBeforeCF := b.TotalPortfolioValue().InexactFloat64() // You'll need to create this helper method.

		// 2. If this isn't the very first cash flow, calculate the sub-period return.
		if b.lastValuation != 0 {
			subPeriodReturn := (valueBeforeCF - b.lastValuation) / b.lastValuation
			// 3. Geometrically link this return to the running total.
			b.linkedTWR *= 1 + subPeriodReturn
		}
		// 4. Update the lastValuation to the value *after* the cash flow.
		b.lastValuation = valueBeforeCF + cashFlowAmount.InexactFloat64()
	}
}

// apply processes a single event and updates the Balance state accordingly.
func (b *Balance) apply(e event, method CostBasisMethod) error {
	switch v := e.(type) {
	case creditCash:
		if b.initialValue.IsZero() {
			b.initialValue = v.amount
		}
		b.computeTWR(v.amount)
		b.cashAccounts[v.currency] = b.cashAccounts[v.currency].Add(v.amount)
	case debitCash:
		b.computeTWR(v.amount.Neg())
		b.cashAccounts[v.currency] = b.cashAccounts[v.currency].Sub(v.amount)
	case acquireLot:
		newLot := lot{
			Date:     v.on,
			Quantity: v.quantity,
			Cost:     v.cost,
		}
		b.lots[v.security] = append(b.lots[v.security], newLot)
	case disposeLot:
		currentLots := b.lots[v.security]
		var costOfSale decimal.Decimal

		switch method {
		case FIFO:
			costOfSale = currentLots.fifoCostOfSelling(v.quantity)
		case AverageCost:
			costOfSale = currentLots.averageCostOfSelling(v.quantity)
		default:
			return fmt.Errorf("unsupported cost basis method: %v", method)
		}

		b.lots[v.security] = currentLots.sell(v.quantity)
		gain := v.proceeds.Sub(costOfSale)
		b.realizedGains[v.security] = b.realizedGains[v.security].Add(gain)

	case creditCounterparty:
		if b.initialValue.IsZero() {
			b.initialValue = v.amount
		}
		b.counterpartyAccounts[v.account] = b.counterpartyAccounts[v.account].Add(v.amount)
	case debitCounterparty:
		b.counterpartyAccounts[v.account] = b.counterpartyAccounts[v.account].Sub(v.amount)
	case splitShare:
		num := decimal.NewFromInt(v.numerator)
		den := decimal.NewFromInt(v.denominator)
		for i, l := range b.lots[v.security] {
			b.lots[v.security][i].Quantity = l.Quantity.Mul(num).Div(den)
		}
	case declareSecurity:
		b.securities[v.ticker] = NewSecurity(v.id, v.ticker, v.currency)
	case declareCounterparty:
		b.counterpartyCur[v.account] = v.currency
	case updatePrice:
		b.prices[v.security] = v.price
	case updateForex:
		b.forex[v.cur] = v.rate
	default:
		return fmt.Errorf("unknown event type: %T", v)
	}
	return nil
}

// Currency returns the reporting currency for aggregated metrics.
func (b *Balance) Currency() string { return b.cur }

// Currencies returns a iteration over all existing currency in the balance.
func (b *Balance) Currencies() iter.Seq[string] {
	currencies := make(map[string]struct{})
	for cur := range b.cashAccounts {
		currencies[cur] = struct{}{}
	}
	for _, sec := range b.securities {
		currencies[sec.Currency()] = struct{}{}
	}
	for _, cur := range b.counterpartyCur {
		currencies[cur] = struct{}{}
	}
	currencies[b.cur] = struct{}{} // Add reporting currency
	keys := slices.Collect(maps.Keys(currencies))
	slices.Sort(keys)
	return slices.Values(keys)
}

// Securities returns an interator over all securities in the balance.
func (b *Balance) Securities() iter.Seq[Security] {
	keys := slices.Collect(maps.Keys(b.securities))
	slices.Sort(keys)
	return func(yield func(Security) bool) {
		for _, ticker := range keys {
			if !yield(b.securities[ticker]) {
				return
			}
		}
	}
}

func (b *Balance) Counterparties() iter.Seq[string] {
	keys := slices.Collect(maps.Keys(b.counterpartyAccounts))
	slices.Sort(keys)
	return slices.Values(keys)
}

// Position returns the quantity of a security held.
func (b *Balance) Position(ticker string) decimal.Decimal {
	var totalQuantity decimal.Decimal
	for _, l := range b.lots[ticker] {
		totalQuantity = totalQuantity.Add(l.Quantity)
	}
	return totalQuantity
}

// CostBasis returns the total cost basis of a security.
func (b *Balance) CostBasis(ticker string) decimal.Decimal {
	var totalCost decimal.Decimal
	for _, l := range b.lots[ticker] {
		totalCost = totalCost.Add(l.Cost)
	}
	return totalCost
}

// RealizedGain returns the realized gain of a security.
func (b *Balance) RealizedGain(ticker string) decimal.Decimal {
	return b.realizedGains[ticker]
}

// MarketValue returns the total market value of a security.
func (b *Balance) MarketValue(ticker string) decimal.Decimal {
	price, ok := b.prices[ticker]
	if !ok {
		return decimal.Zero
	}
	return b.Position(ticker).Mul(price)
}

// Return returns the TWR return since inception
func (b *Balance) Return() float64 {
	return b.linkedTWR - 1.0
}

// ConvertedMarketValue returns the total market value of a security in the reporting currency.
func (b *Balance) secCurrency(ticker string) string { return b.securities[ticker].currency }

// Cash returns the balance of a specific currency.
// convert amount in 'currency' to the reporting currency.
func (b *Balance) convert(amount decimal.Decimal, currency string) decimal.Decimal {
	if currency == b.cur {
		return amount
	} else {
		rate := b.forex[currency]
		return amount.Mul(rate)
	}
}

func (b *Balance) Cash(currency string) decimal.Decimal {
	return b.cashAccounts[currency]
}

// Counterparty returns the balance of a specific counterparty account.
func (b *Balance) Counterparty(account string) decimal.Decimal {
	return b.counterpartyAccounts[account]
}

// CounterpartyCurrency	returns the currency of a specific counterparty account.
func (b *Balance) CounterpartyCurrency(account string) string {
	return b.counterpartyCur[account]
}

// TotalRealizedGain returns the total realized gains accross all holdings.
func (b *Balance) TotalRealizedGain() decimal.Decimal {
	total := decimal.Zero
	for sec, gain := range b.realizedGains {
		gain = b.convert(gain, b.secCurrency(sec))
		total = total.Add(gain)
	}
	return total
}

// TotalMarketValue returns the total market value of all securities in the portfolio.
func (b *Balance) TotalMarketValue() decimal.Decimal {
	total := decimal.Zero
	for ticker := range b.securities {
		mv := b.MarketValue(ticker)
		mv = b.convert(mv, b.secCurrency(ticker))
		total = total.Add(mv)
	}
	return total
}

func (b *Balance) TotalCostBasis() decimal.Decimal {
	total := decimal.Zero
	for ticker := range b.securities {
		mv := b.CostBasis(ticker)
		mv = b.convert(mv, b.secCurrency(ticker))
		total = total.Add(mv)
	}
	return total
}

// TotalCash returns the total cash balance across all currencies, converted to the reporting currency.
func (b *Balance) TotalCash() decimal.Decimal {
	total := decimal.Zero
	for currency, amount := range b.cashAccounts {
		total = total.Add(b.convert(amount, currency))
	}
	return total
}

// TotalCounterparty returns the total balance across all counterparty accounts, converted to the reporting currency.
func (b *Balance) TotalCounterparty() decimal.Decimal {
	total := decimal.Zero
	for acc, amount := range b.counterpartyAccounts {
		cur := b.counterpartyCur[acc]
		total = total.Add(b.convert(amount, cur))
	}
	return total
}

// TotalPortfolioValue returns the total value of the portfolio, including securities, cash, and counterparty accounts.
func (b *Balance) TotalPortfolioValue() decimal.Decimal {
	return b.TotalMarketValue().
		Add(b.TotalCash()).
		Add(b.TotalCounterparty())
}

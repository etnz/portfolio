package portfolio

import (
	"path/filepath"
	"strings"
	"testing"
)

// TestEncodeDecodeMarketData check that market data can be persisted and reimported without any difference.
func TestEncodeDecodeMarketData(t *testing.T) {
	// Start from a very simple example, generated by gemini from the textual definition of the import format.
	sample1 := `
{"ticker":"AAPL","id":"US0378331005","history":{"2025-07-29":195.5,"2025-07-30":196.25,"2025-07-31":198.1}}
{"ticker":"NVDA","id":"US67066G1040","history":{"2025-07-29":175.51,"2025-07-30":178.9,"2025-07-31":177.85}}
`

	sample1 = strings.Trim(sample1, "\n\t")

	market, err := ImportMarketData(strings.NewReader(sample1))
	if err != nil {
		t.Fatalf("Import() has unexpected error: %v", err)
	}

	datafile := filepath.Join(t.TempDir(), "market.jsonl")

	if err := EncodeMarketData(datafile, market); err != nil {
		t.Fatalf("Persist(%q) has unexpected error: %v", datafile, err)
	}

	market2, err := DecodeMarketData(datafile)
	if err != nil {
		t.Fatalf("Load(%q) has unexpected error: %v", datafile, err)
	}

	// export the market data to check consistency

	sb := strings.Builder{}
	if err := ExportMarketData(&sb, market2); err != nil {
		t.Fatalf("market2.Export() has unexpected error %v", err)
	}

	got := sb.String()
	got = strings.Trim(got, "\n\t")

	if got != sample1 {
		t.Errorf("Persist/Load sequence is not stable \ngot:\n%s \nwant: \n%s", got, sample1)
	}

}

package portfolio

import (
	"bytes"
	"encoding/json"
	"reflect"
	"strings"
	"testing"
	"time"

	"github.com/etnz/portfolio/date"
)

// TestEncodeDecodeMarketData check that market data can be persisted and reimported without any difference.
func TestEncodeDecodeMarketData(t *testing.T) {
	// Start from a very simple example, generated by gemini from the textual definition of the import format.
	sample1 := `
{"ticker":"AAPL","id":"US0378331005","history":{"2025-07-29":195.5,"2025-07-30":196.25,"2025-07-31":198.1}}
{"ticker":"NVDA","id":"US67066G1040","history":{"2025-07-29":175.51,"2025-07-30":178.9,"2025-07-31":177.85}}
`

	sample1 = strings.Trim(sample1, "\n\t")

	market, err := ImportMarketData(strings.NewReader(sample1))
	if err != nil {
		t.Fatalf("Import() has unexpected error: %v", err)
	}
	folder := t.TempDir()

	if err := EncodeMarketData(folder, market); err != nil {
		t.Fatalf("Persist(%q) has unexpected error: %v", folder, err)
	}

	market2, err := DecodeMarketData(folder)
	if err != nil {
		t.Fatalf("Load(%q) has unexpected error: %v", folder, err)
	}

	// export the market data to check consistency

	sb := strings.Builder{}
	if err := ExportMarketData(&sb, market2); err != nil {
		t.Fatalf("market2.Export() has unexpected error %v", err)
	}

	got := sb.String()
	got = strings.Trim(got, "\n\t")

	if got != sample1 {
		t.Errorf("Persist/Load sequence is not stable \ngot:\n%s \nwant: \n%s", got, sample1)
	}

}

func TestDecodeLedger(t *testing.T) {
	// A multi-line string representing a JSONL stream with all command types
	jsonlStream := `
{"command":"buy","date":"2025-08-01","security":"AAPL","quantity":10,"price":195.5}
{"command":"deposit","date":"2025-08-02","amount":5000,"currency":"USD"}
{"command":"sell","date":"2025-08-02","security":"GOOG","quantity":5,"price":140.2}
{"command":"dividend","date":"2025-08-03","security":"AAPL","amount":5.50}
{"command":"withdraw","date":"2025-08-04","amount":1000,"currency":"USD"}
{"command":"convert","date":"2025-08-05","fromCurrency":"USD","fromAmount":2000,"toCurrency":"EUR","toAmount":1850.50}
`
	reader := strings.NewReader(jsonlStream)

	ledger, err := DecodeLedger(reader)

	// 1. Check for unexpected errors
	if err != nil {
		t.Fatalf("DecodeLedger() returned an unexpected error: %v", err)
	}

	// 2. Check the number of transactions decoded
	expectedCount := 6
	if len(ledger.transactions) != expectedCount {
		t.Fatalf("DecodeLedger() decoded wrong number of transactions. Got: %d, want: %d", len(ledger.transactions), expectedCount)
	}

	// 3. Check the type of each decoded transaction
	expectedTypes := []reflect.Type{
		reflect.TypeOf(Buy{}),
		reflect.TypeOf(Deposit{}),
		reflect.TypeOf(Sell{}),
		reflect.TypeOf(Dividend{}),
		reflect.TypeOf(Withdraw{}),
		reflect.TypeOf(Convert{}),
	}

	for i, tx := range ledger.Transactions() {
		if reflect.TypeOf(tx) != expectedTypes[i] {
			t.Errorf("Transaction %d has wrong type. Got: %T, want: %v", i+1, tx, expectedTypes[i])
		}
	}
}

func TestEncodeLedger(t *testing.T) {
	// 1. Arrange: Create test data in a deliberately unsorted order.
	// Note that tx2 and tx3 have the same date. Their relative order must be preserved.
	tx1 := NewBuy(date.New(2025, time.August, 3), "", "AAPL", 0, 0, "USD")
	tx2 := NewDeposit(date.New(2025, time.August, 1), "", "", 1000)
	tx3 := NewSell(date.New(2025, time.August, 1), "", "GOOG", 0, 0, "EUR") // Same date as tx2

	ledger := &Ledger{
		transactions: []Transaction{
			tx1, // Should be last
			tx2, // Should be first
			tx3, // Should be second (stable sort)
		},
	}

	// Manually sort the transactions to build the expected output string.
	expectedOrder := []Transaction{tx2, tx3, tx1}
	var expectedOutput strings.Builder
	for _, tx := range expectedOrder {
		jsonData, _ := json.Marshal(tx)
		expectedOutput.Write(jsonData)
		expectedOutput.WriteString("\n")
	}

	var buffer bytes.Buffer

	// 2. Act: Call the Save function.
	err := EncodeLedger(&buffer, ledger)

	// 3. Assert: Check the results.
	if err != nil {
		t.Fatalf("EncodeLedger() returned an unexpected error: %v", err)
	}

	if got := buffer.String(); got != expectedOutput.String() {
		t.Errorf("EncodeLedger() produced incorrect output.\nGot:\n%s\nWant:\n%s", got, expectedOutput.String())
	}
}

// TestEncodeDecodeLedger verifies that loading an unsorted JSONL file and immediately
// saving it results in a correctly and stably sorted file.
func TestEncodeDecodeLedger(t *testing.T) {
	// 1. Arrange: Define a long, unsorted list of transactions.
	// Note the two transactions on 2025-08-05 are in a specific order.
	unsortedJSONL := `
{"command":"deposit","date":"2025-08-02","amount":5000,"currency":"USD"}
{"command":"buy","date":"2025-08-03","security":"AAPL","quantity":10,"price":195.5}
{"command":"buy","date":"2025-08-01","security":"GOOG","quantity":5,"price":140.2}
{"command":"convert","date":"2025-08-05","fromCurrency":"USD","fromAmount":1000,"toCurrency":"EUR","toAmount":920}
{"command":"dividend","date":"2025-08-04","security":"AAPL","amount":5.5}
{"command":"sell","date":"2025-08-05","memo":"trim position","security":"GOOG","quantity":2,"price":142}
{"command":"withdraw","date":"2025-08-06","amount":500,"currency":"USD"}
{"command":"buy","date":"2025-08-04","memo":"buy the dip","security":"MSFT","quantity":15,"price":410}
{"command":"deposit","date":"2025-08-01","memo":"wire transfer","amount":10000,"currency":"EUR"}
`

	// Define the expected output after a stable sort by date.
	// The two 2025-08-01 transactions are now at the top, in their original order.
	// The two 2025-08-05 transactions are also in their original relative order.
	expectedSortedJSONL := `{"command":"buy","date":"2025-08-01","security":"GOOG","quantity":5,"price":140.2}
{"command":"deposit","date":"2025-08-01","memo":"wire transfer","amount":10000,"currency":"EUR"}
{"command":"deposit","date":"2025-08-02","amount":5000,"currency":"USD"}
{"command":"buy","date":"2025-08-03","security":"AAPL","quantity":10,"price":195.5}
{"command":"dividend","date":"2025-08-04","security":"AAPL","amount":5.5}
{"command":"buy","date":"2025-08-04","memo":"buy the dip","security":"MSFT","quantity":15,"price":410}
{"command":"convert","date":"2025-08-05","fromCurrency":"USD","fromAmount":1000,"toCurrency":"EUR","toAmount":920}
{"command":"sell","date":"2025-08-05","memo":"trim position","security":"GOOG","quantity":2,"price":142}
{"command":"withdraw","date":"2025-08-06","amount":500,"currency":"USD"}
`

	// 2. Act: Load the unsorted data, then save it to a new buffer.
	reader := strings.NewReader(unsortedJSONL)
	ledger, err := DecodeLedger(reader)
	if err != nil {
		t.Fatalf("DecodeLedger() failed unexpectedly: %v", err)
	}

	var savedBuffer bytes.Buffer
	err = EncodeLedger(&savedBuffer, ledger)
	if err != nil {
		t.Fatalf("EncodeLedger() failed unexpectedly: %v", err)
	}

	// 3. Assert: Compare the saved result with the expected sorted output.
	// We trim space to handle leading/trailing newlines for a robust comparison.
	got := strings.TrimSpace(savedBuffer.String())
	want := strings.TrimSpace(expectedSortedJSONL)

	if got != want {
		t.Errorf("Decode/Encode cycle produced incorrect output.\nGot:\n%s\n\nWant:\n%s", got, want)
	}
}

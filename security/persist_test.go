package security

import (
	"strings"
	"testing"
)

// TestPersistLoad check that a db can be persisted and reimported without any difference.
func TestPersistLoad(t *testing.T) {
	// Start from a very simple example, generated by gemini from the textual definition of the import format.
	sample1 := `
{"ticker":"AAPL","id":"US0378331005","history":{"2025-07-29":195.5,"2025-07-30":196.25,"2025-07-31":198.1}}
{"ticker":"NVDA","id":"US67066G1040","history":{"2025-07-29":175.51,"2025-07-30":178.9,"2025-07-31":177.85}}
`

	sample1 = strings.Trim(sample1, "\n\t")

	securities := New()
	if err := securities.Import(strings.NewReader(sample1)); err != nil {
		t.Fatalf("Import() has unexpected error: %v", err)
	}
	folder := t.TempDir()

	if err := securities.Persist(folder); err != nil {
		t.Fatalf("Persist(%q) has unexpected error: %v", folder, err)
	}

	db2, err := Load(folder)
	if err != nil {
		t.Fatalf("Load(%q) has unexpected error: %v", folder, err)
	}

	// export the database to check consistency

	sb := strings.Builder{}
	if err := db2.Export(&sb); err != nil {
		t.Fatalf("db2.Export() has unexpected error %v", err)
	}

	got := sb.String()
	got = strings.Trim(got, "\n\t")

	if got != sample1 {
		t.Errorf("Persist/Load sequence is not stable \ngot:\n%s \nwant: \n%s", got, sample1)
	}

}
